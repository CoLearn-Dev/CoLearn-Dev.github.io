use std::collections::HashMap;
use std::fmt::Debug;
use std::iter::Successors;
use tonic::{transport::Server, Request, Response, Status};

// These module names are auto-generated by tonic so there's nothing I can do to control the uppercase and lowercase
// This is because tonic's parser thinks the service name DDS is one single word in dds.proto
use crate::dds::dds_server::{Dds, DdsServer};
use crate::dds::{
    CreateEntryRequest, CreateNewUserReply, CreateNewUserRequest, DeleteEntryRequest,
    ImportNewUserRequest, LoadStringReply, LoadStringRequest, ReadBatchReply, ReadBatchRequest,
    ReadEntryReply, ReadEntryRequest, ReadKeyListReply, ReadKeyListRequest, RefreshTokenRequest,
    StoreStringRequest, SuccessBool, TokenReply, UpdateEntryRequest,
};

use chrono::TimeZone;
use jsonwebtoken::{Algorithm, DecodingKey, Validation};
use serde::{Deserialize, Serialize};
use std::sync::{Arc, Mutex};

use ::dds::storage::common::Storage;
use ::dds::storage::dummy::DummyStorage;
use once_cell::sync::OnceCell;
use openssl::sha::sha256;
use rand::RngCore;
use secp256k1::ecdsa::Signature;
use secp256k1::{Error, Message, PublicKey, Secp256k1};
use tonic::metadata::MetadataMap;
use tonic::transport::ServerTlsConfig;

pub mod dds {
    tonic::include_proto!("dds");
}

static MAP: OnceCell<Mutex<HashMap<String, Vec<u8>>>> = OnceCell::new();

static JWT_SECRET: OnceCell<[u8; 32]> = OnceCell::new();

static STORAGE: OnceCell<Box<dyn Storage + Send + Sync>> = OnceCell::new();

#[derive(Debug, Default)]
pub struct MyService {}

#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    role: String,
    user_id: String,
    exp: i64,
}

// Once again, this is "Dds" from the auto-generated code from tonic
#[tonic::async_trait]
impl Dds for MyService {
    async fn store_string(
        &self,
        request: Request<StoreStringRequest>,
    ) -> Result<Response<SuccessBool>, Status> {
        println!("Got a request: {:?}", request);
        println!(
            "The role is: {}\nThe user_id is: {}",
            request.metadata().get("role").unwrap().to_str().unwrap(),
            request.metadata().get("user_id").unwrap().to_str().unwrap()
        );
        let body: StoreStringRequest = request.into_inner();
        let key: String = body.key;
        let value: String = body.value;
        let value = value.into_bytes();

        let status = true;

        let storage = STORAGE.get().unwrap();
        storage.create(&String::default(), key, &value);

        let reply = SuccessBool {
            success: true.into(),
        };

        Ok(Response::new(reply))
    }

    async fn load_string(
        &self,
        request: Request<LoadStringRequest>,
    ) -> Result<Response<LoadStringReply>, Status> {
        println!("Got a request: {:?}", request);
        println!(
            "The role is: {}",
            request.metadata().get("role").unwrap().to_str().unwrap()
        );
        let body: LoadStringRequest = request.into_inner();
        let key: String = body.key;

        let status = true;

        let res = STORAGE
            .get()
            .unwrap()
            .read(&String::default(), &key)
            .unwrap();
        let value = match res {
            None => return Err(Status::not_found("this key is not found on the server")),
            Some(bytes) => String::from_utf8(bytes.to_vec()).unwrap(),
        };
        let reply = LoadStringReply {
            value: value.into(),
        };

        Ok(Response::new(reply))
    }

    async fn create_new_user(
        &self,
        request: Request<CreateNewUserRequest>,
    ) -> Result<Response<CreateNewUserReply>, Status> {
        Self::check_admin_token(request.metadata())?;
        let body: CreateNewUserRequest = request.into_inner();
        let expire_time: i64 = body.expire_time;
        let mut rng = secp256k1::rand::thread_rng();
        let secp = Secp256k1::new();
        let (secret_key, public_key) = secp.generate_keypair(&mut rng);
        let secret_key = secret_key.serialize_secret();
        let public_key = public_key.serialize();
        let token = jsonwebtoken::encode(
            &jsonwebtoken::Header::default(),
            &Claims {
                role: "user".to_string(),
                user_id: base64::encode(&public_key),
                exp: expire_time,
            },
            &jsonwebtoken::EncodingKey::from_secret(JWT_SECRET.get().unwrap()),
        )
        .unwrap();
        let reply = CreateNewUserReply {
            secret_key: secret_key.to_vec(),
            public_key: public_key.to_vec(),
            token,
        };
        Ok(Response::new(reply))
    }

    async fn refresh_token(
        &self,
        request: Request<RefreshTokenRequest>,
    ) -> Result<Response<TokenReply>, Status> {
        println!("Got a request: {:?}", request);
        Self::check_admin_token(request.metadata())?;
        let secret = JWT_SECRET.get().unwrap();
        let body: RefreshTokenRequest = request.into_inner();
        let token = body.token;
        let token = jsonwebtoken::decode::<Claims>(
            &token,
            &jsonwebtoken::DecodingKey::from_secret(secret),
            &jsonwebtoken::Validation::default(),
        )
        .unwrap();
        let token = token.claims;
        let token = jsonwebtoken::encode(
            &jsonwebtoken::Header::default(),
            &Claims {
                role: token.role,
                user_id: token.user_id,
                exp: body.expire_time,
            },
            &jsonwebtoken::EncodingKey::from_secret(secret),
        )
        .unwrap();
        let reply = TokenReply { token };
        Ok(Response::new(reply))
    }

    // UNTESTED, need client side to test, haven't written client side yet
    async fn import_new_user(
        &self,
        request: Request<ImportNewUserRequest>,
    ) -> Result<Response<TokenReply>, Status> {
        Self::check_admin_token(request.metadata())?;
        let body: ImportNewUserRequest = request.into_inner();
        let mut public_key_vec: Vec<u8> = body.public_key;
        let public_key: PublicKey = match PublicKey::from_slice(&public_key_vec) {
            Ok(pk) => pk,
            Err(e) => {
                return Err(Status::invalid_argument(
                    "The public key could not be decoded in compressed serialized format.",
                ))
            }
        };

        let current_timestamp: i64 = body.current_timestamp;
        let expire_time = body.expire_time;
        let signature: Vec<u8> = body.signature;
        let signature = match Signature::from_compact(&signature) {
            Ok(sig) => sig,
            Err(e) => {
                return Err(Status::invalid_argument(
                    "The signature could not be decoded in EDCSA",
                ))
            }
        };

        if chrono::Utc
            .timestamp(current_timestamp, 0)
            .signed_duration_since(chrono::Utc::now())
            .num_hours()
            > 48
        {
            return Err(Status::unauthenticated(
                "the timestamp is more than 48 hours before the current time",
            ));
        }
        public_key_vec.extend_from_slice(&current_timestamp.to_le_bytes());
        let message = Message::from_slice(&sha256(&public_key_vec)).unwrap();
        let secp = Secp256k1::new();
        match secp.verify_ecdsa(&message, &signature, &public_key) {
            Ok(_) => {}
            Err(e) => return Err(Status::invalid_argument("Invalid Signature")),
        }
        let token = jsonwebtoken::encode(
            &jsonwebtoken::Header::default(),
            &Claims {
                role: "user".to_string(),
                user_id: base64::encode(&public_key.serialize()),
                exp: expire_time,
            },
            &jsonwebtoken::EncodingKey::from_secret(JWT_SECRET.get().unwrap()),
        )
        .unwrap();
        let reply = TokenReply { token };
        Ok(Response::new(reply))
    }

    async fn create_entry(
        &self,
        request: Request<CreateEntryRequest>,
    ) -> Result<Response<SuccessBool>, Status> {
        Self::check_user_token(request.metadata())?;
        let user_id = Self::get_user_id(request.metadata());
        let body: CreateEntryRequest = request.into_inner();
        let key: String = body.key;
        let value: Vec<u8> = body.value;
        let storage = STORAGE.get().unwrap();
        storage.create(&user_id, key, &value);

        Ok(Response::new(SuccessBool { success: true }))
    }

    async fn read_entry(
        &self,
        request: Request<ReadEntryRequest>,
    ) -> Result<Response<ReadEntryReply>, Status> {
        Self::check_user_token(request.metadata())?;
        let user_id = Self::get_user_id(request.metadata());
        let body: ReadEntryRequest = request.into_inner();
        let key: String = body.key;
        let storage = STORAGE.get().unwrap();
        let value = storage.read(&user_id, &key);
        match value {
            Ok(v) => Ok(Response::new(ReadEntryReply { value: v })),
            Err(e) => Err(Status::aborted(format!("{}", e))),
        }
    }

    async fn update_entry(
        &self,
        request: Request<UpdateEntryRequest>,
    ) -> Result<Response<SuccessBool>, Status> {
        Self::check_user_token(request.metadata())?;
        let user_id = Self::get_user_id(request.metadata());
        let body: UpdateEntryRequest = request.into_inner();
        let key: String = body.key;
        let value: Vec<u8> = body.value;
        let storage = STORAGE.get().unwrap();
        storage.update(&user_id, &key, &value);

        Ok(Response::new(SuccessBool { success: true }))
    }

    async fn delete_entry(
        &self,
        request: Request<DeleteEntryRequest>,
    ) -> Result<Response<SuccessBool>, Status> {
        Self::check_user_token(request.metadata())?;
        let user_id = Self::get_user_id(request.metadata());
        let body: DeleteEntryRequest = request.into_inner();
        let key: String = body.key;
        let storage = STORAGE.get().unwrap();
        storage.delete(&user_id, &key);

        Ok(Response::new(SuccessBool { success: true }))
    }

    async fn read_key_list(
        &self,
        request: Request<ReadKeyListRequest>,
    ) -> Result<Response<ReadKeyListReply>, Status> {
        Self::check_user_token(request.metadata())?;
        let user_id = Self::get_user_id(request.metadata());
        let body: ReadKeyListRequest = request.into_inner();
        let storage = STORAGE.get().unwrap();
        let keys = storage.read_key_list(&user_id);
        match keys {
            Ok(k) => Ok(Response::new(ReadKeyListReply { keys: k })),
            Err(e) => Err(Status::aborted(format!("{}", e))),
        }
    }

    async fn read_batch(
        &self,
        request: Request<ReadBatchRequest>,
    ) -> Result<Response<ReadBatchReply>, Status> {
        Self::check_user_token(request.metadata())?;
        let user_id = Self::get_user_id(request.metadata());
        let body: ReadBatchRequest = request.into_inner();
        let keys: Vec<String> = body.keys;
        let storage = STORAGE.get().unwrap();
        let values = storage.read_batch(&user_id, keys);
        let mut res: Vec<ReadEntryReply> = Vec::new();
        match values {
            Ok(vec) => {
                for v in vec {
                    res.push(ReadEntryReply { value: v });
                }
                Ok(Response::new(ReadBatchReply { entries: res }))
            }
            Err(e) => Err(Status::aborted(format!("{}", e))),
        }
    }
}

impl MyService {
    pub fn check_admin_token(request_metadata: &MetadataMap) -> Result<(), Status> {
        let role = request_metadata.get("role").unwrap().to_str().unwrap();
        if role != "admin" {
            return Err(Status::permission_denied(
                "This procedure requires an admin token, which you did not provide.",
            ));
        } else {
            Ok(())
        }
    }
    pub fn check_user_token(request_metadata: &MetadataMap) -> Result<(), Status> {
        let role = request_metadata.get("role").unwrap().to_str().unwrap();
        if role != "admin" && role != "user" {
            return Err(Status::permission_denied(
                "This procedure needs an admin or user token, which you did not provide.",
            ));
        } else {
            Ok(())
        }
    }
    pub fn get_user_id(request_metadata: &MetadataMap) -> String {
        request_metadata
            .get("user_id")
            .unwrap()
            .to_str()
            .unwrap()
            .to_string()
    }
}

fn get_admin_token() -> String {
    let secret = JWT_SECRET.get().unwrap();
    let exp = chrono::Utc::now() + chrono::Duration::hours(48);
    let claims = Claims {
        role: "admin".to_string(),
        user_id: "_admin".to_string(),
        exp: exp.timestamp(),
    };
    let token = jsonwebtoken::encode(
        &jsonwebtoken::Header::default(),
        &claims,
        &jsonwebtoken::EncodingKey::from_secret(secret),
    )
    .unwrap();
    token
}

async fn print_admin_token() {
    let token = get_admin_token();
    println!("{}", token);
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    MAP.set(Mutex::new(HashMap::<String, Vec<u8>>::new()))
        .unwrap();
    STORAGE.set(Box::new(DummyStorage::new()));
    let mut jwt_secret: [u8; 32] = [0; 32];
    let mut rng = rand::thread_rng();

    rng.fill_bytes(&mut jwt_secret);
    // let jwt_secret = String::from_utf8(jwt_secret.to_vec()).unwrap();
    println!("JWT secret: {:?}", jwt_secret);
    JWT_SECRET.set(jwt_secret);

    tokio::spawn(print_admin_token());

    let addr = "127.0.0.1:8080".parse()?;
    let service = MyService::default();
    let service = DdsServer::with_interceptor(service, check_auth);

    /* TLS */
    // reading cert and key of server from disk
    let cert = include_str!("../cfssl/pd-server.pem");
    let key = include_str!("../cfssl/pd-server-key.pem");
    // creating identity from cert and key
    let server_identity = tonic::transport::Identity::from_pem(cert.as_bytes(), key.as_bytes());

    // https://developers.cloudflare.com/cloudflare-one/identity/devices/mutual-tls-authentication
    let client_ca_cert = tokio::fs::read("cfssl/ca.pem").await?;
    let client_ca_cert = tonic::transport::Certificate::from_pem(client_ca_cert);

    // creating tls config
    let tls = ServerTlsConfig::new()
        .identity(server_identity)
        .client_ca_root(client_ca_cert);

    Server::builder()
        // .tls_config(ServerTlsConfig::new().identity(server_identity))?
        .tls_config(tls)?
        .add_service(service)
        .serve(addr)
        .await?;

    Ok(())
}

fn check_auth(req: Request<()>) -> Result<Request<()>, Status> {
    println!("Intercepting request: {:?}", req);

    let token = match req.metadata().get("authorization") {
        Some(t) => {
            println!("The authorization header is: {}", t.to_str().unwrap());
            t.to_str().unwrap()
        }
        None => {
            println!("Debug: No valid auth token");
            return Err(Status::unauthenticated("No valid auth token"));
        }
    };
    let secret = JWT_SECRET.get().unwrap();
    println!("{:#?}", secret);
    let token = match jsonwebtoken::decode::<Claims>(
        token,
        &DecodingKey::from_secret(secret),
        &Validation::default(),
    ) {
        Ok(token_data) => token_data,
        Err(e) => {
            println!("Debug: wrong secret. {}", e);
            return Err(Status::unauthenticated("Wrong secret."));
        }
    };

    let mut req = req;
    req.metadata_mut()
        .insert("role", token.claims.role.parse().unwrap());
    req.metadata_mut()
        .insert("user_id", token.claims.user_id.parse().unwrap());

    Ok(req)
}
